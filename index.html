<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Punto</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- NEW: Background gradient and logo --- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #232526 0%, #414345 100%);
            color: #d1d5db;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .logo {
            width: 64px;
            height: 64px;
            margin-bottom: 8px;
            border-radius: 50%;
            background: radial-gradient(circle at 60% 40%, #f59e0b 60%, #f97316 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: #fff;
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.25);
            user-select: none;
        }

        /* --- IMPROVED BOARD --- */
        .main-container {
            display: flex;
            flex-direction: row;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            background: rgba(55, 65, 81, 0.95);
            border-radius: 18px;
            box-shadow: 0 10px 32px rgba(0,0,0,0.25), 0 1.5px 0 #f59e0b inset;
            padding: 0;
            gap: 0;
            overflow: hidden;
        }

        .game-controls {
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background-color: #1f2937;
            padding: 24px 12px;
            border-radius: 8px 0 0 8px;
            height: 100vh;
            min-width: 200px;
            box-sizing: border-box;
        }

        .game-board-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            height: 100vh;
            justify-content: center;
            overflow: hidden;
        }

        .title {
            font-size: 2rem;
            font-weight: bold;
            color: #f3f4f6;
            text-align: center;
        }
        
        .message {
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            height: 1.5rem;
            transition: color 0.3s ease;
            min-height: 2.2rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-layout {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            align-items: center;
            height: 100%;
            justify-content: center;
        }

        .game-middle-row {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
            align-items: center;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px;
            aspect-ratio: 1 / 1;
            width: 60vmin;
            height: 60vmin;
            max-width: calc(100vw - 350px);
            max-height: calc(100vh - 80px);
            background: linear-gradient(135deg, #22223b 60%, #37306b 100%);
            box-shadow: 0 6px 24px rgba(0,0,0,0.18), 0 0 0 4px #f59e0b33 inset;
            padding: 8px;
            border-radius: 12px;
            box-sizing: border-box;
        }
        #deck-area-top, #deck-area-bottom {
            width: 60vmin;
            max-width: calc(100vw - 350px);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #deck-area-left, #deck-area-right {
            height: 60vmin;
            max-height: calc(100vh - 80px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        @media (max-width: 900px), (max-height: 700px) {
            .main-container {
                flex-direction: column;
                align-items: stretch;
                height: 100vh;
                max-height: 100vh;
            }
            .game-controls {
                flex-direction: row;
                width: 100vw;
                height: auto;
                min-width: 0;
                border-radius: 0 0 8px 8px;
                padding: 12px 4px;
            }
            .game-board-container {
                height: 100%;
                min-height: 0;
            }
            .grid-container,
            #deck-area-top,
            #deck-area-bottom {
                width: 80vw;
                max-width: 80vw;
                height: 80vw;
                max-height: 60vh;
            }
            #deck-area-left, #deck-area-right {
                height: 80vw;
                max-height: 60vh;
            }
        }
        @media (max-width: 600px), (max-height: 500px) {
            .grid-container,
            #deck-area-top,
            #deck-area-bottom {
                width: 96vw;
                max-width: 96vw;
                height: 96vw;
                max-height: 50vh;
            }
            #deck-area-left, #deck-area-right {
                height: 96vw;
                max-height: 50vh;
            }
            .game-controls {
                font-size: 0.9rem;
                padding: 6px 2px;
            }
        }

        .card-slot {
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(55, 65, 81, 0.7);
            border: 2px solid #4b5563;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
            border-radius: 8px;
            cursor: pointer;
            aspect-ratio: 1 / 1;
            width: 100%;
            height: 100%;
            min-width: 0;
            min-height: 0;
            box-sizing: border-box;
            overflow: hidden;
            padding: 0; /* Remove padding */
        }

        .card {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 6px;
            background: linear-gradient(135deg, #fff8 60%, #fff2 100%);
            border: 2.5px solid #fff4;
            box-shadow: 0 2px 12px rgba(0,0,0,0.18), 0 0 0 2px #fff2 inset;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            box-sizing: border-box;
            overflow: hidden;
            min-width: 0;
            min-height: 0;
        }

        /* UX IMPROVEMENT: Highlight valid moves for the player */
        .card-slot.valid-move-indicator:not(.occupied) {
            background: linear-gradient(135deg, #f59e0b44 60%, #f59e0b22 100%);
            border: 2px solid #f59e0b;
            box-shadow: 0 0 8px 2px #f59e0b55;
        }
        .card-slot:not(.occupied):hover {
            background: linear-gradient(135deg, #f59e0b22 60%, #fff1 100%);
            border-color: #f59e0b;
            transform: scale(1.05);
            z-index: 2;
        }

        .card-dots {
            position: relative; /* Changed from absolute */
            width: 100%;
            height: 100%;
            display: grid;
            gap: 4px;
            pointer-events: none;
            min-width: 0;
            min-height: 0;
            justify-items: center;
            align-items: center;
        }

        .dot {
            background-color: white;
            border-radius: 50%;
            width: 80%;
            height: 80%;
            margin: auto;
            aspect-ratio: 1 / 1;
            max-width: 18px;
            max-height: 18px;
            min-width: 6px;
            min-height: 6px;
        }
        
        .dots-1 { display: flex; justify-content: center; align-items: center; }
        .dots-1 .dot { width: 33%; height: 33%; }
        .dots-2, .dots-3, .dots-4, .dots-5, .dots-6, .dots-7, .dots-8, .dots-9 {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }
        .dots-2 .dot:nth-child(1) { grid-area: 1 / 1; }
        .dots-2 .dot:nth-child(2) { grid-area: 3 / 3; }
        .dots-3 .dot:nth-child(1) { grid-area: 1 / 1; }
        .dots-3 .dot:nth-child(2) { grid-area: 2 / 2; }
        .dots-3 .dot:nth-child(3) { grid-area: 3 / 3; }
        .dots-4 .dot:nth-child(1) { grid-area: 1 / 1; }
        .dots-4 .dot:nth-child(2) { grid-area: 1 / 3; }
        .dots-4 .dot:nth-child(3) { grid-area: 3 / 1; }
        .dots-4 .dot:nth-child(4) { grid-area: 3 / 3; }
        .dots-5 .dot:nth-child(1) { grid-area: 1 / 1; }
        .dots-5 .dot:nth-child(2) { grid-area: 1 / 3; }
        .dots-5 .dot:nth-child(3) { grid-area: 2 / 2; }
        .dots-5 .dot:nth-child(4) { grid-area: 3 / 1; }
        .dots-5 .dot:nth-child(5) { grid-area: 3 / 3; }
        .dots-6 .dot:nth-child(1) { grid-area: 1 / 1; }
        .dots-6 .dot:nth-child(2) { grid-area: 1 / 3; }
        .dots-6 .dot:nth-child(3) { grid-area: 2 / 1; }
        .dots-6 .dot:nth-child(4) { grid-area: 2 / 3; }
        .dots-6 .dot:nth-child(5) { grid-area: 3 / 1; }
        .dots-6 .dot:nth-child(6) { grid-area: 3 / 3; }
        .dots-9 .dot { grid-area: auto; } /* All 9 dots */
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .player-setup-controls {
            display: flex;
            flex-direction: row;
            gap: 12px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 9999px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            flex: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
        }

        .btn-setup { background-color: #4b5563; color: #d1d5db; }
        .btn-setup.active, .btn-restart:hover, .btn-start:hover {
            background: linear-gradient(90deg, #f59e0b 60%, #f97316 100%);
            color: #fff;
            box-shadow: 0 4px 16px #f59e0b44;
        }
        .btn-restart, .btn-start { background-color: #f97316; color: white; }
        .btn-restart:hover, .btn-start:hover { background-color: #ea580c; transform: translateY(-2px); }
        .btn-restart:active, .btn-start:active { transform: translateY(0); }

        /* --- PLAYER TURN INDICATOR --- */
        .turn-indicator {
            display: inline-block;
            width: 1.5em;
            height: 1.5em;
            border-radius: 50%;
            margin-right: 0.5em;
            vertical-align: middle;
            box-shadow: 0 0 0 2px #fff8;
        }
        .turn-player { background: linear-gradient(135deg, #3b82f6 60%, #2563eb 100%); }
        .turn-ai { background: linear-gradient(135deg, #ef4444 60%, #b91c1c 100%); }
        .turn-ai2 { background: linear-gradient(135deg, #10b981 60%, #047857 100%); }
        .turn-ai3 { background: linear-gradient(135deg, #6366f1 60%, #3730a3 100%); }

        .modal {
            display: none; position: fixed; z-index: 100;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0, 0, 0, 0.7);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: #374151; padding: 24px; border-radius: 12px;
            text-align: center; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 400px; width: 90%;
        }
        .modal-message { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 20px; }
        
        .deck-area { display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .deck-area-vertical { min-height: 250px; }
        .deck-area-horizontal { min-width: 250px; }
        .player-deck, .ai-deck { display: flex; position: relative; }
        
        .card-in-hand, .card-back {
            width: 48px;
            height: 48px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }
        
        .player-deck.horizontal, .ai-deck.horizontal { flex-direction: row-reverse; }
        .player-deck.horizontal .card-in-hand, .ai-deck.horizontal .card-back { margin-right: -50px; }
        .player-deck.horizontal .card-in-hand:last-child, .ai-deck.horizontal .card-back:last-child { margin-right: 0; }
        .player-deck.horizontal .card-in-hand.next-card { box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.4); transform: translateX(10px); z-index: 10; }
        
        .player-deck.vertical, .ai-deck.vertical { flex-direction: column-reverse; }
        .player-deck.vertical .card-in-hand, .ai-deck.vertical .card-back { margin-bottom: -50px; }
        .player-deck.vertical .card-in-hand:last-child, .ai-deck.vertical .card-back:last-child { margin-bottom: 0; }
        .player-deck.vertical .card-in-hand.next-card { box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.4); transform: translateY(10px); z-index: 10; }
        
        .card-back { background-color: var(--card-back-color); transition: transform 0.2s ease; }

        /* --- Player/AI card colors are now owner-based for 4 player mode */
        .card-player1 { background: linear-gradient(135deg, #3b82f6 60%, #2563eb 100%); }
        .card-ai1 { background: linear-gradient(135deg, #ef4444 60%, #b91c1c 100%); }
        .card-ai2 { background: linear-gradient(135deg, #10b981 60%, #047857 100%); }
        .card-ai3 { background: linear-gradient(135deg, #6366f1 60%, #3730a3 100%); }
        
        /* NEW: Custom colors for 2-player mode cards */
        .card-color-blue { background: linear-gradient(135deg, #3b82f6 60%, #2563eb 100%); }
        .card-color-green { background: linear-gradient(135deg, #10b981 60%, #047857 100%); }
        .card-color-red { background: linear-gradient(135deg, #ef4444 60%, #b91c1c 100%); }
        .card-color-yellow { background: linear-gradient(135deg, #f59e0b 60%, #d97706 100%); }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="game-controls">
            <!-- NEW: Add a logo above the title -->
            <div class="logo">🟡</div>
            <h1 class="title">Punto</h1>
            <div class="controls">
                <div class="player-setup-controls">
                    <button class="btn btn-setup active" id="setup-2-players">2 Players</button>
                    <button class="btn btn-setup" id="setup-4-players">4 Players</button>
                </div>
            </div>
            <button class="btn btn-start" id="start-button">Start Game</button>
            <button class="btn btn-restart" id="restart-button" style="display:none;">Restart Game</button>
        </div>

        <div class="game-board-container" id="game-board-container">
            <div class="message" id="game-message">Select player count and start!</div>
            <div class="game-layout">
                <div id="deck-area-top" class="deck-area deck-area-horizontal"></div>
                <div class="game-middle-row">
                    <div id="deck-area-left" class="deck-area deck-area-vertical"></div>
                    <div class="grid-container" id="grid"></div>
                    <div id="deck-area-right" class="deck-area deck-area-vertical"></div>
                </div>
                <div id="deck-area-bottom" class="deck-area deck-area-horizontal"></div>
            </div>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-message" id="modal-message"></div>
            <button class="btn btn-restart" id="modal-close-button">Play Again</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const GRID_SIZE = 9;
        const AI_THINKING_TIME = 750;
        const CARD_VALUES = Array.from({ length: 9 }, (_, i) => i + 1);
        const PLAYER_COLORS = {
            'player1': 'player1', 'ai1': 'ai1', 'ai2': 'ai2', 'ai3': 'ai3'
        };
        const CENTER_INDEX = 4 * GRID_SIZE + 4;

        // --- GAME STATE ---
        let players = [];
        let board = Array(GRID_SIZE * GRID_SIZE).fill(null);
        let turnCount = 0;
        let gameOver = false;
        let currentMode = 2;
        let currentPlayerIndex = 0;

        // --- DOM ELEMENTS ---
        const gridElement = document.getElementById('grid');
        const gameMessageElement = document.getElementById('game-message');
        const deckAreas = {
            top: document.getElementById('deck-area-top'),
            bottom: document.getElementById('deck-area-bottom'),
            left: document.getElementById('deck-area-left'),
            right: document.getElementById('deck-area-right')
        };
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const modalElement = document.getElementById('modal');
        const modalMessageElement = document.getElementById('modal-message');
        const modalCloseButton = document.getElementById('modal-close-button');
        const setup2PlayersBtn = document.getElementById('setup-2-players');
        const setup4PlayersBtn = document.getElementById('setup-4-players');

        // --- EVENT LISTENERS ---
        startButton.addEventListener('click', () => startGame(currentMode));
        restartButton.addEventListener('click', () => startGame(currentMode));
        modalCloseButton.addEventListener('click', () => {
            modalElement.style.display = 'none';
            startGame(currentMode);
        });
        setup2PlayersBtn.addEventListener('click', () => setPlayerMode(2));
        setup4PlayersBtn.addEventListener('click', () => setPlayerMode(4));

        function setPlayerMode(count) {
            currentMode = count;
            setup2PlayersBtn.classList.toggle('active', count === 2);
            setup4PlayersBtn.classList.toggle('active', count === 4);
        }

        // --- CORE GAME LOGIC ---
        function startGame(playerCount) {
            currentMode = playerCount;
            gameOver = false;
            turnCount = 0;
            board.fill(null);
            
            players = [];
            if (playerCount === 2) {
                // NEW RULE: 2-player mode uses two card colors per player
                players.push({ id: 'player1', name: 'You', deck: createColoredDeck(['blue', 'green']), isHuman: true });
                players.push({ id: 'ai1', name: 'AI', deck: createColoredDeck(['red', 'yellow']), isHuman: false });
            } else if (playerCount === 4) {
                players.push({ id: 'player1', name: 'You', deck: createSimpleDeck('player1'), isHuman: true });
                players.push({ id: 'ai1', name: 'AI 1', deck: createSimpleDeck('ai1'), isHuman: false });
                players.push({ id: 'ai2', name: 'AI 2', deck: createSimpleDeck('ai2'), isHuman: false });
                players.push({ id: 'ai3', name: 'AI 3', deck: createSimpleDeck('ai3'), isHuman: false });
            }
            
            currentPlayerIndex = Math.floor(Math.random() * players.length);
            
            startButton.style.display = 'none';
            restartButton.style.display = 'block';
            modalElement.style.display = 'none';

            initializeGrid();
            updateUI();
            nextTurn();
        }
        
        function nextTurn() {
            if (players.every(p => p.deck.length === 0) && !gameOver) {
                endGame(null, true);
                return;
            }
            
            if (gameOver) return;

            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            const currentPlayer = players[currentPlayerIndex];

            if(currentPlayer.deck.length === 0) {
                 nextTurn();
                 return;
            }
            
            updateUI();

            if (currentPlayer.isHuman) {
                updateValidMoveHighlights(true);
            } else {
                updateValidMoveHighlights(false);
                setTimeout(aiMove, AI_THINKING_TIME);
            }
        }
        
        function handlePlayerMove(index) {
            const currentPlayer = players[currentPlayerIndex];
            if (gameOver || !currentPlayer.isHuman || currentPlayer.deck.length === 0) return;
        
            const cardToPlay = currentPlayer.deck[currentPlayer.deck.length - 1];
            
            if (canPlaceCard(index, cardToPlay.value)) {
                placeCard(index, currentPlayer.deck.pop(), currentPlayer.id);
                turnCount++;
        
                const winInfo = checkWin(index);
                if (winInfo) {
                    endGame(currentPlayer, false, winInfo.line);
                    return;
                }
                nextTurn();
            } else {
                gameMessageElement.textContent = "Invalid move!";
                setTimeout(() => updateUI(), 1500);
            }
        }

        function placeCard(index, card, ownerId) {
            // NEW: The card object now contains a value and a color.
            board[index] = { value: card.value, owner: ownerId, color: card.color };
        }
        
        function endGame(winner, isDraw = false, winningLine = []) {
            gameOver = true;
            updateValidMoveHighlights(false);
            updateUI(winningLine);

            let message;
            if (isDraw) {
                message = "It's a draw!";
            } else {
                message = `${winner.name} wins!`;
            }

            modalMessageElement.textContent = message;
            setTimeout(() => {
                 modalElement.style.display = 'flex';
            }, 1000);
        }

        // --- RULE CHECKING ---
        function getWinLength() {
            return currentMode === 2 ? 5 : 4;
        }
        
        function isAdjacent(index) {
            if (turnCount === 0) return index === CENTER_INDEX;

            const row = Math.floor(index / GRID_SIZE);
            const col = index % GRID_SIZE;

            for (let r_offset = -1; r_offset <= 1; r_offset++) {
                for (let c_offset = -1; c_offset <= 1; c_offset++) {
                    if (r_offset === 0 && c_offset === 0) continue;
                    const r = row + r_offset;
                    const c = col + c_offset;
                    if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r * GRID_SIZE + c]) {
                        return true;
                    }
                }
            }
            return false;
        }

        function canPlaceCard(index, cardValue) {
            if (board[index] === null) {
                return isAdjacent(index);
            } else {
                return cardValue > board[index].value;
            }
        }

        // UPDATED: Check for win based on owner and card color for 2-player mode.
        function checkWin(placedIndex) {
            const placedCard = board[placedIndex];
            if (!placedCard) return null;

            const ownerId = placedCard.owner;
            const winLength = getWinLength();
            const r_start = Math.floor(placedIndex / GRID_SIZE);
            const c_start = placedIndex % GRID_SIZE;
            const directions = [{dr:0, dc:1}, {dr:1, dc:0}, {dr:1, dc:1}, {dr:1, dc:-1}];

            for (const dir of directions) {
                let line = [placedIndex];
                // Check in one direction
                for (let i = 1; i < winLength; i++) {
                    const r = r_start + i * dir.dr;
                    const c = c_start + i * dir.dc;
                    const idx = r * GRID_SIZE + c;
                    
                    if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[idx] && board[idx].owner === ownerId) {
                         // NEW: Check for same card color in 2-player mode.
                        if (currentMode === 2 && board[idx].color !== placedCard.color) {
                            break;
                        }
                        line.push(idx);
                    } else {
                        break;
                    }
                }
                // Check in the opposite direction
                for (let i = 1; i < winLength; i++) {
                    const r = r_start - i * dir.dr;
                    const c = c_start - i * dir.dc;
                    const idx = r * GRID_SIZE + c;
                    
                    if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[idx] && board[idx].owner === ownerId) {
                        // NEW: Check for same card color in 2-player mode.
                        if (currentMode === 2 && board[idx].color !== placedCard.color) {
                            break;
                        }
                        line.push(idx);
                    } else {
                        break;
                    }
                }
                if (line.length >= winLength) {
                    return { winner: ownerId, line: line };
                }
            }
            return null;
        }

        // --- DECK MANAGEMENT ---
        // NEW: Creates a deck with two colors for a player
        function createColoredDeck(colors) {
            const deck = [];
            colors.forEach(color => {
                for (let i = 1; i <= 9; i++) {
                    deck.push({ value: i, color: color });
                }
            });
            return shuffle(deck);
        }
        
        // OLD: Keeps this for the 4-player mode
        function createSimpleDeck(ownerId) {
            const deck = [];
            for (let i = 0; i < 1; i++) { // One set of cards per player
                deck.push(...CARD_VALUES);
            }
            // MODIFIED: Return objects with a value and a color based on the owner
            return shuffle(deck.map(v => ({ value: v, color: PLAYER_COLORS[ownerId] })));
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // --- UI RENDERING ---
        function initializeGrid() {
            gridElement.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const slot = document.createElement('div');
                slot.className = 'card-slot';
                slot.dataset.index = i;
                slot.addEventListener('click', () => handlePlayerMove(i));
                gridElement.appendChild(slot);
            }
        }

        function updateUI(winningLine = []) {
            // Update Board
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const slot = gridElement.children[i];
                slot.innerHTML = '';
                slot.classList.remove('occupied');
                
                const cardData = board[i];
                if (cardData) {
                    renderCard(cardData.value, cardData.owner, cardData.color, slot);
                    slot.classList.add('occupied');
                    if (winningLine.includes(i)) {
                        slot.firstChild.classList.add('winning-card');
                    }
                }
            }

            // Update Decks
            Object.values(deckAreas).forEach(area => area.innerHTML = '');
            const humanPlayer = players.find(p => p.isHuman);
            if(humanPlayer) renderDeck(humanPlayer, deckAreas.bottom, 'horizontal');
            
            const aiPlayers = players.filter(p => !p.isHuman);
            if(aiPlayers.length > 0) renderDeck(aiPlayers[0], deckAreas.top, 'horizontal');
            if(aiPlayers.length > 1) renderDeck(aiPlayers[1], deckAreas.left, 'vertical');
            if(aiPlayers.length > 2) renderDeck(aiPlayers[2], deckAreas.right, 'vertical');
            
            // Update Message
            const currentPlayer = players[currentPlayerIndex];
            if (gameOver) return;
            
            if (currentPlayer.isHuman) {
                gameMessageElement.textContent = `Your turn! Get ${getWinLength()} in a row.`;
            } else {
                gameMessageElement.textContent = `${currentPlayer.name} is thinking...`;
            }
        }

        // UPDATED: Render card based on its color, not just owner
        function renderCard(value, owner, color, parentElement) {
            const card = document.createElement('div');
            // MODIFIED: Use the specific color if available, otherwise fall back to owner ID
            card.className = `card card-${color}`;
            
            const dotsContainer = document.createElement('div');
            dotsContainer.className = `card-dots dots-${value}`;
            for (let i = 0; i < value; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dotsContainer.appendChild(dot);
            }
            card.appendChild(dotsContainer);
            parentElement.appendChild(card);
        }

        // UPDATED: Render cards with correct colors for 2-player mode
        function renderDeck(player, container, orientation) {
            const deckWrapper = document.createElement('div');
            deckWrapper.className = `deck-area`;

            const label = document.createElement('span');
            label.textContent = `${player.name} (${player.deck.length} left)`;
            deckWrapper.appendChild(label);
            
            const deckContainer = document.createElement('div');
            deckContainer.className = (player.isHuman ? 'player-deck' : 'ai-deck') + ` ${orientation}`;
            
            const displayDeck = player.isHuman ? player.deck : Array(player.deck.length).fill(null);
            
            displayDeck.forEach((cardData, index) => {
                const cardWrapper = document.createElement('div');
                if (player.isHuman) {
                    cardWrapper.className = `card-in-hand`;
                    if (index === displayDeck.length - 1) cardWrapper.classList.add('next-card');
                    
                    // Render the card with its specific color
                    renderCard(cardData.value, player.id, cardData.color, cardWrapper);
                } else {
                    cardWrapper.className = 'card-back';
                }
                deckContainer.appendChild(cardWrapper);
            });

            deckWrapper.appendChild(deckContainer);
            container.appendChild(deckWrapper);
        }

        // UX IMPROVEMENT: Show player where they can move
        function updateValidMoveHighlights(show) {
            const player = players[currentPlayerIndex];
            if (!player || player.deck.length === 0) return;

            const cardToPlay = player.deck[player.deck.length - 1];
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const slot = gridElement.children[i];
                if (show && turnCount === 0) {
                    if (i === CENTER_INDEX) {
                        slot.classList.add('valid-move-indicator');
                    } else {
                        slot.classList.remove('valid-move-indicator');
                    }
                } else if (show && canPlaceCard(i, cardToPlay.value)) {
                    slot.classList.add('valid-move-indicator');
                } else {
                    slot.classList.remove('valid-move-indicator');
                }
            }
        }

        // --- AI LOGIC ---
        function aiMove() {
            const currentPlayer = players[currentPlayerIndex];
            if (gameOver || currentPlayer.deck.length === 0) return;

            const cardToPlay = currentPlayer.deck[currentPlayer.deck.length - 1];
            let bestMove = { index: -1, score: -Infinity };
            const validMoves = [];

            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                if (canPlaceCard(i, cardToPlay.value)) {
                    validMoves.push(i);
                }
            }

            if (validMoves.length === 0) {
                nextTurn();
                return;
            }

            for (const index of validMoves) {
                const score = scoreMove(index, currentPlayer, cardToPlay);
                if (score > bestMove.score) {
                    bestMove = { index, score };
                }
            }
            
            if (bestMove.index === -1) {
                bestMove.index = validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            placeCard(bestMove.index, currentPlayer.deck.pop(), currentPlayer.id);
            turnCount++;

            const winInfo = checkWin(bestMove.index);
            if (winInfo) {
                endGame(currentPlayer, false, winInfo.line);
                return;
            }
            
            nextTurn();
        }

        function scoreMove(index, player, cardToPlay) {
            let score = 0;
            const opponents = players.filter(p => p.id !== player.id);

            const originalCell = board[index];
            board[index] = { value: cardToPlay.value, owner: player.id, color: cardToPlay.color };

            if (checkWin(index)?.owner === player.id) {
                board[index] = originalCell;
                return 10000;
            }

            for(const op of opponents) {
                if(op.deck.length > 0) {
                    const opponentCardToPlay = op.deck[op.deck.length - 1];
                    board[index] = { value: opponentCardToPlay.value, owner: op.id, color: opponentCardToPlay.color };
                    if (checkWin(index)?.owner === op.id) {
                        score += 5000;
                    }
                    board[index] = { value: cardToPlay.value, owner: player.id, color: cardToPlay.color };
                }
            }
            
            // MODIFIED: Pass cardToPlay.color to getLineLength for accurate scoring in 2-player mode
            score += Math.pow(getLineLength(index, player.id, cardToPlay.color), 2) * 10;
            
            for(const op of opponents) {
                if (board[index] && board[index].owner !== op.id) {
                    score += getLineLength(index, op.id, board[index].color) * 5;
                }
            }
            
            if (originalCell !== null) {
                score += originalCell.value * 2;
            }

            board[index] = originalCell;
            return score;
        }

        function getLineLength(index, ownerId, color) {
            let maxLen = 0;
            const r_start = Math.floor(index / GRID_SIZE);
            const c_start = index % GRID_SIZE;
            const directions = [{dr:0, dc:1}, {dr:1, dc:0}, {dr:1, dc:1}, {dr:1, dc:-1}];

            for(const dir of directions) {
                let currentLen = 1;
                for(let i = 1; i < getWinLength(); i++) {
                    const r = r_start + i * dir.dr, c = c_start + i * dir.dc;
                    const cardAtIdx = board[r * GRID_SIZE + c];
                    if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || cardAtIdx?.owner !== ownerId) break;
                    // MODIFIED: Only check for color match in 2-player mode
                    if (currentMode === 2 && cardAtIdx?.color !== color) break;
                    currentLen++;
                }
                for(let i = 1; i < getWinLength(); i++) {
                    const r = r_start - i * dir.dr, c = c_start - i * dir.dc;
                    const cardAtIdx = board[r * GRID_SIZE + c];
                    if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || cardAtIdx?.owner !== ownerId) break;
                    // MODIFIED: Only check for color match in 2-player mode
                    if (currentMode === 2 && cardAtIdx?.color !== color) break;
                    currentLen++;
                }
                if (currentLen > maxLen) maxLen = currentLen;
            }
            return maxLen;
        }

        // --- INITIALIZE ---
        initializeGrid();

    </script>
</body>
</html>
